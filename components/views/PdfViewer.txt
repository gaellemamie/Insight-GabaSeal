"use client";

import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { motion } from "framer-motion";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Slider } from "@/components/ui/slider";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Toggle } from "@/components/ui/toggle";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Separator } from "@/components/ui/separator";
import { toast } from "sonner";
import { 
  Upload, Link as LinkIcon, ZoomIn, ZoomOut, Search, RotateCw, RotateCcw, 
  Download, Printer, FileCheck2, ShieldCheck, ShieldAlert, 
  FileWarning, ListTree, Eye, EyeOff, Sun, Moon, ChevronLeft, ChevronRight,
  Info, Layers, Type, Ruler, Undo2, Redo2
} from "lucide-react";

// PDF.js
// IMPORTANT: ensure your bundler loads the worker correctly. Vite/Next 15+ example below.
// If you use Next.js app router, add this at the top level (e.g., layout.tsx):
//   (globalThis as any).pdfjsWorker = await import("pdfjs-dist/build/pdf.worker.min?worker");
// Or use the CDN fallback by setting GlobalWorkerOptions.workerSrc.
// @ts-ignore
import * as pdfjsLib from "pdfjs-dist/legacy/build/pdf";
// @ts-ignore - types for text layer may be missing
import * as pdfjsViewer from "pdfjs-dist/web/pdf_viewer";
import "pdfjs-dist/web/pdf_viewer.css";

// Crypto + CMS/PKI
// We'll use PKI.js to verify CMS signatures embedded in the PDF /Contents.
import { Crypto } from "@peculiar/webcrypto";
import { fromBER } from "asn1js";
import * as pkijs from "pkijs";

// ---------- Types ----------
export type PdfSource = string | ArrayBuffer | File | Blob;

export type RichPdfSignerViewerProps = {
  /** URL, ArrayBuffer, or File */
  src?: PdfSource;
  /** Called when signatures have been parsed */
  onSignaturesParsed?: (info: ParsedSignatureInfo[]) => void;
  /** 0-based page index to start with */
  initialPage?: number;
  /** Dark or light UI */
  theme?: "light" | "dark";
  /** Enable experimental revision tracker (incremental updates) */
  enableRevisionTimeline?: boolean;
  /** Allow user annotations (client-side only, non-destructive). */
  enableAnnotations?: boolean;
  className?: string;
};

export type ParsedSignatureInfo = {
  name?: string;
  reason?: string;
  location?: string;
  contactInfo?: string;
  signingTime?: Date | null;
  isValid?: boolean;
  isDigestMatch?: boolean;
  certificateSubject?: string;
  certificateIssuer?: string;
  certificateSerial?: string;
  byteRange?: [number, number, number, number];
  contentsLength?: number;
  revisionIndex?: number; // if we can infer from ByteRange end
  errors?: string[];
};

// Utility: read ArrayBuffer from diverse inputs
async function toArrayBuffer(src: PdfSource): Promise<ArrayBuffer> {
  if (typeof src === "string") {
    const res = await fetch(src);
    return await res.arrayBuffer();
  }
  if (src instanceof ArrayBuffer) return src;
  const blob = src instanceof Blob ? src : new Blob([src as any]);
  return await blob.arrayBuffer();
}

// Extract /ByteRange and /Contents for each signature in the PDF using a regex scan over bytes.
// This is a pragmatic approach that works for typical PDFs using incremental updates.
function extractSignaturesRaw(pdfBytes: Uint8Array): { byteRange: number[]; contentsHex: string }[] {
  const str = new TextDecoder("latin1").decode(pdfBytes); // latin1 preserves 0x00-0xFF
  const results: { byteRange: number[]; contentsHex: string }[] = [];
  const sigRegex = /\/ByteRange\s*\[\s*(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s*\][\s\S]*?\/Contents\s*<([0-9A-Fa-f]+)>/g;
  let m: RegExpExecArray | null;
  while ((m = sigRegex.exec(str)) !== null) {
    const byteRange = [0, 1, 2, 3].map((i) => parseInt(m![i + 1], 10));
    const contentsHex = m[5];
    results.push({ byteRange, contentsHex });
  }
  return results;
}

// Verify one CMS signature using PKI.js against concatenated ByteRange.
async function verifyOneSignature(
  pdfBytes: Uint8Array,
  byteRange: number[],
  contentsHex: string
): Promise<ParsedSignatureInfo> {
  const errors: string[] = [];
  try {
    // Build the signed message data = bytes in ByteRange[0..1) + ByteRange[2..3)
    const [b0, b1, b2, b3] = byteRange;
    const part1 = pdfBytes.slice(b0, b0 + b1);
    const part2 = pdfBytes.slice(b2, b2 + b3);
    const joined = new Uint8Array(part1.length + part2.length);
    joined.set(part1, 0);
    joined.set(part2, part1.length);

    // Decode CMS from hex
    const cmsBytes = new Uint8Array(contentsHex.length / 2);
    for (let i = 0; i < contentsHex.length; i += 2) {
      cmsBytes[i / 2] = parseInt(contentsHex.substr(i, 2), 16);
    }

    // Initialize WebCrypto for PKI.js
    // @ts-ignore
    const crypto = (typeof window !== "undefined" && (window.crypto || (window as any).msCrypto)) || new Crypto();
    // @ts-ignore
    pkijs.setEngine("webcrypto", crypto, crypto.subtle);

    // Parse CMS
    const asn1 = fromBER(cmsBytes.buffer);
    if (asn1.offset === -1) {
      errors.push("Failed to parse CMS signature.");
      return { errors, byteRange: byteRange as any, contentsLength: cmsBytes.length } as ParsedSignatureInfo;
    }
    const cms = new pkijs.ContentInfo({ schema: asn1.result });
    if (cms.contentType !== pkijs.ContentInfo.SIGNED_DATA) {
      errors.push("CMS content is not SignedData.");
    }
    const signedData = new pkijs.SignedData({ schema: cms.content });

    // Attach the exact signed data (the byte ranges) for verification
    const verification = await signedData.verify({ data: joined.buffer, trustedCerts: [], checkChain: false });

    // Extract signer + cert info
    let name: string | undefined;
    let signingTime: Date | null = null;
    let certSubject: string | undefined;
    let certIssuer: string | undefined;
    let serial: string | undefined;

    try {
      const signerInfo = signedData.signerInfos[0];
      // Attributes
      const attrs = signerInfo.signedAttrs;
      if (attrs) {
        const cnAttr = attrs.attributes.find((a: any) => a.type === "1.2.840.113549.1.9.3"); // contentType (placeholder)
        const timeAttr = attrs.attributes.find((a: any) => a.type === "1.2.840.113549.1.9.5"); // signingTime
        if (timeAttr && timeAttr.values?.[0]?.toDate) signingTime = timeAttr.values[0].toDate();
      }
      const cert = signedData.certificates?.[0];
      if (cert) {
        // Check if cert has subject and issuer properties (X.509 Certificate)
        if ("subject" in cert && "issuer" in cert) {
          certSubject = cert.subject?.typesAndValues?.map((tv: any) => `${tv.type.split(".").slice(-1)[0]}=${tv.value.valueBlock.value}`).join(", ");
          certIssuer = cert.issuer?.typesAndValues?.map((tv: any) => `${tv.type.split(".").slice(-1)[0]}=${tv.value.valueBlock.value}`).join(", ");
        } else {
          certSubject = "Unknown subject";
          certIssuer = "Unknown issuer";
        }
        // Serial number (if available)
        if ("serialNumber" in cert && cert.serialNumber?.valueBlock?.valueHex) {
          serial = Buffer.from(cert.serialNumber.valueBlock.valueHex).toString("hex");
        } else {
          serial = "Unknown serial";
        }
      }
      name = certSubject;
    } catch (e: any) {
      errors.push("Failed to extract signer/certificate info");
    }

    return {
      name,
      signingTime,
      isValid: verification, // boolean
      isDigestMatch: !!verification,
      certificateIssuer: certIssuer,
      certificateSubject: certSubject,
      certificateSerial: serial,
      byteRange: byteRange as any,
      contentsLength: cmsBytes.length,
      errors: errors.length ? errors : undefined,
    };
  } catch (e: any) {
    errors.push(e?.message || String(e));
    return { errors, byteRange: byteRange as any } as ParsedSignatureInfo;
  }
}

// Attempt to infer revision index based on the end of the ByteRange[1]
// In incremental updates, each signature usually seals the current revision.
function inferRevisions(sigInfos: ParsedSignatureInfo[]) {
  const ends = sigInfos.map((s) => (s.byteRange ? s.byteRange[0] + s.byteRange[1] : 0));
  const uniqueSorted = Array.from(new Set(ends)).sort((a, b) => a - b);
  const map = new Map<number, number>();
  uniqueSorted.forEach((end, idx) => map.set(end, idx + 1));
  for (const s of sigInfos) {
    if (s.byteRange) {
      const end = s.byteRange[0] + s.byteRange[1];
      s.revisionIndex = map.get(end) || undefined;
    }
  }
}

// ---------- Component ----------
export default function RichPdfSignerViewer(props: RichPdfSignerViewerProps) {
  const { src, onSignaturesParsed, initialPage = 0, theme = "light", enableRevisionTimeline = true, enableAnnotations = true, className } = props;

  const containerRef = useRef<HTMLDivElement | null>(null);
  const [pdfDoc, setPdfDoc] = useState<any>(null);
  const [pdfBytes, setPdfBytes] = useState<Uint8Array | null>(null);
  const [pageNum, setPageNum] = useState(initialPage + 1);
  const [pageCount, setPageCount] = useState(0);
  const [scale, setScale] = useState(1.0);
  const [rotation, setRotation] = useState(0);
  const [searchQuery, setSearchQuery] = useState("");
  const [loading, setLoading] = useState(false);
  const [dark, setDark] = useState(theme === "dark");
  const [signatures, setSignatures] = useState<ParsedSignatureInfo[] | null>(null);
  const [revisions, setRevisions] = useState<number[]>([]);
  const [showTextLayer, setShowTextLayer] = useState(true);
  const [showThumbnails, setShowThumbnails] = useState(true);
  const [annotRects, setAnnotRects] = useState<{ page: number; rect: { x: number; y: number; w: number; h: number } }[]>([]);

  // Load PDF
  const loadPdf = useCallback(async (_src: PdfSource) => {
    setLoading(true);
    try {
      const ab = await toArrayBuffer(_src);
      const u8 = new Uint8Array(ab);
      setPdfBytes(u8);

      // PDF.js worker config (fallback)
      // @ts-ignore
      if (pdfjsLib.GlobalWorkerOptions && !pdfjsLib.GlobalWorkerOptions.workerSrc) {
        // CDN fallback; in production prefer bundler worker import
        // @ts-ignore
        pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.worker.min.js";
      }

      const loadingTask = pdfjsLib.getDocument({ data: u8, useSystemFonts: true, cMapUrl: "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.7.76/cmaps/", cMapPacked: true });
      const doc = await loadingTask.promise;
      setPdfDoc(doc);
      setPageCount(doc.numPages);
      setPageNum(Math.min(Math.max(1, initialPage + 1), doc.numPages));
      toast.success(`Loaded PDF with ${doc.numPages} pages`);

      // Parse signatures in background (but we complete it synchronously in this run)
      const raw = extractSignaturesRaw(u8);
      const parsed: ParsedSignatureInfo[] = [];
      for (const r of raw) {
        try {
          const info = await verifyOneSignature(u8, r.byteRange, r.contentsHex);
          parsed.push(info);
        } catch (e: any) {
          parsed.push({ errors: [e?.message || String(e)], byteRange: r.byteRange as any, contentsLength: r.contentsHex.length / 2 });
        }
      }
      inferRevisions(parsed);
      setSignatures(parsed);
      onSignaturesParsed?.(parsed);

      const revs = Array.from(new Set(parsed.map((p) => p.revisionIndex).filter(Boolean))) as number[];
      setRevisions(revs.sort((a, b) => a - b));
    } catch (e: any) {
      toast.error(e?.message || String(e));
    } finally {
      setLoading(false);
    }
  }, [initialPage, onSignaturesParsed]);

  // Render current page into the container
  const renderPage = useCallback(async () => {
    if (!pdfDoc || !containerRef.current) return;
    const page = await pdfDoc.getPage(pageNum);

    const viewport = page.getViewport({ scale, rotation });
    const container = containerRef.current;
    container.innerHTML = "";

    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    canvas.width = viewport.width;
    canvas.height = viewport.height;
    canvas.style.width = `${viewport.width}px`;
    canvas.style.height = `${viewport.height}px`;

    container.appendChild(canvas);

    await page.render({ canvasContext: ctx, viewport }).promise;

    if (showTextLayer) {
      // @ts-ignore
      const textLayerDiv = document.createElement("div");
      textLayerDiv.className = "textLayer";
      container.appendChild(textLayerDiv);
      // @ts-ignore
      const textContent = await page.getTextContent();
      // @ts-ignore
      pdfjsLib.renderTextLayer({ textContent, container: textLayerDiv, viewport, textDivs: [] });
    }
  }, [pdfDoc, pageNum, scale, rotation, showTextLayer]);

  useEffect(() => { renderPage(); }, [renderPage]);

  // Mount/load when src changes
  useEffect(() => { if (src) loadPdf(src); }, [src, loadPdf]);

  // Handlers
  const onFile = (e: React.ChangeEvent<HTMLInputElement>) => {
    const f = e.target.files?.[0];
    if (f) loadPdf(f);
  };

  const onPrev = () => setPageNum((p) => Math.max(1, p - 1));
  const onNext = () => setPageNum((p) => Math.min(pageCount, p + 1));

  const onZoomIn = () => setScale((s) => Math.min(3, +(s + 0.1).toFixed(2)));
  const onZoomOut = () => setScale((s) => Math.max(0.25, +(s - 0.1).toFixed(2)));

  const rotateCW = () => setRotation((r) => (r + 90) % 360);
  const rotateCCW = () => setRotation((r) => (r + 270) % 360);

  const toggleTheme = () => setDark((d) => !d);

  // Simple page search (client-side text layer scan). For big PDFs consider a worker.
  const onSearch = async () => {
    if (!pdfDoc || !searchQuery) return;
    try {
      for (let i = pageNum; i <= pdfDoc.numPages; i++) {
        const page = await pdfDoc.getPage(i);
        // @ts-ignore
        const textContent = await page.getTextContent();
        const fullText = textContent.items.map((it: any) => it.str).join(" ").toLowerCase();
        if (fullText.includes(searchQuery.toLowerCase())) {
          setPageNum(i);
          toast.success(`Found on page ${i}`);
          return;
        }
      }
      toast.message("No more matches.");
    } catch (e: any) {
      toast.error(e?.message || String(e));
    }
  };

  // Export current canvas as image
  const onDownloadPagePng = () => {
    const canvas = containerRef.current?.querySelector("canvas");
    if (!canvas) return;
    const url = canvas.toDataURL("image/png");
    const a = document.createElement("a");
    a.href = url;
    a.download = `page-${pageNum}.png`;
    a.click();
  };

  // Download original PDF
  const onDownloadPdf = () => {
    if (!pdfBytes) return;
    const blob = new Blob([pdfBytes], { type: "application/pdf" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "document.pdf";
    a.click();
    URL.revokeObjectURL(url);
  };

  // Print
  const onPrint = () => {
    if (!pdfBytes) return;
    const blob = new Blob([pdfBytes], { type: "application/pdf" });
    const url = URL.createObjectURL(blob);
    const iframe = document.createElement("iframe");
    iframe.style.display = "none";
    iframe.src = url;
    document.body.appendChild(iframe);
    iframe.onload = () => {
      iframe.contentWindow?.focus();
      iframe.contentWindow?.print();
      setTimeout(() => {
        document.body.removeChild(iframe);
        URL.revokeObjectURL(url);
      }, 1000);
    };
  };

  // Annotation: click-drag to draw a rectangle highlight on current page
  useEffect(() => {
    if (!enableAnnotations) return;
    const container = containerRef.current;
    if (!container) return;
    let start: { x: number; y: number } | null = null;
    let overlay: HTMLDivElement | null = null;

    const onDown = (e: MouseEvent) => {
      const rect = container.getBoundingClientRect();
      start = { x: e.clientX - rect.left, y: e.clientY - rect.top };
      overlay = document.createElement("div");
      overlay.style.position = "absolute";
      overlay.style.left = `${start.x}px`;
      overlay.style.top = `${start.y}px`;
      overlay.style.border = "2px solid #22c55e"; // tailwind emerald-500
      overlay.style.background = "rgba(34,197,94,0.15)";
      container.appendChild(overlay);
    };
    const onMove = (e: MouseEvent) => {
      if (!start || !overlay) return;
      const rect = container.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const w = Math.max(2, x - start.x);
      const h = Math.max(2, y - start.y);
      overlay.style.width = `${w}px`;
      overlay.style.height = `${h}px`;
    };
    const onUp = (e: MouseEvent) => {
      if (!start || !overlay) return;
      const w = parseFloat(overlay.style.width || "0");
      const h = parseFloat(overlay.style.height || "0");
      setAnnotRects((prev) => [...prev, { page: pageNum, rect: { x: start!.x, y: start!.y, w, h } }]);
      start = null;
      overlay = null;
    };

    container.addEventListener("mousedown", onDown);
    window.addEventListener("mousemove", onMove);
    window.addEventListener("mouseup", onUp);
    return () => {
      container.removeEventListener("mousedown", onDown);
      window.removeEventListener("mousemove", onMove);
      window.removeEventListener("mouseup", onUp);
    };
  }, [enableAnnotations, pageNum]);

  // UI helpers
  const SignatureBadge: React.FC<{ s: ParsedSignatureInfo }> = ({ s }) => {
    const ok = s.isValid;
    return (
      <div className="flex items-start justify-between gap-4 rounded-2xl border p-3">
        <div>
          <div className="flex items-center gap-2">
            {ok ? <ShieldCheck className="h-4 w-4" /> : <ShieldAlert className="h-4 w-4" />}
            <span className="font-medium">{s.name || "Unknown signer"}</span>
            <Badge variant={ok ? "default" : "destructive"}>{ok ? "Valid" : "Invalid"}</Badge>
          </div>
          <div className="text-sm text-muted-foreground mt-1">
            {s.certificateIssuer && (<div>Issuer: {s.certificateIssuer}</div>)}
            {s.signingTime && (<div>Signed: {s.signingTime.toLocaleString()}</div>)}
            {s.certificateSerial && (<div>Serial: {s.certificateSerial}</div>)}
            {s.byteRange && (<div>ByteRange: [{s.byteRange.join(", ")}]</div>)}
            {s.revisionIndex && (<div>Revision: {s.revisionIndex}</div>)}
            {s.errors && s.errors.length > 0 && (
              <div className="text-red-500">Issues: {s.errors.join("; ")}</div>
            )}
          </div>
        </div>
        <FileCheck2 className={"h-5 w-5 " + (ok ? "text-emerald-600" : "text-red-500")} />
      </div>
    );
  };

  return (
    <div className={"w-full h-full flex flex-col gap-3 " + (dark ? "dark" : "") + (className ? ` ${className}` : "") }>
      <TooltipProvider>
        <Card className="w-full overflow-hidden border-0 shadow-sm">
          <CardHeader className="pb-2">
            <div className="flex flex-wrap items-center gap-2">
              <CardTitle className="text-xl">Rich PDF Signer Viewer</CardTitle>
              <CardDescription>View, inspect signatures, search, and annotate</CardDescription>
            </div>
          </CardHeader>
          <CardContent className="pt-0">
            <div className="flex items-center gap-2 flex-wrap">
              <div className="flex items-center gap-2">
                <Input type="file" accept="application/pdf" onChange={onFile} className="w-56" />
                <Input placeholder="https://…/document.pdf" onKeyDown={(e) => {
                  if (e.key === "Enter") {
                    const url = (e.target as HTMLInputElement).value;
                    if (url) loadPdf(url);
                  }
                }} className="w-72" />
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button variant="outline" size="icon" onClick={() => {
                      const url = (document.activeElement as HTMLInputElement)?.value;
                      if (url?.startsWith("http")) loadPdf(url);
                    }}><LinkIcon className="h-4 w-4"/></Button>
                  </TooltipTrigger>
                  <TooltipContent>Load from URL</TooltipContent>
                </Tooltip>
              </div>

              <Separator orientation="vertical" className="h-8" />

              <div className="flex items-center gap-1">
                <Tooltip><TooltipTrigger asChild><Button size="icon" variant="outline" onClick={onZoomOut}><ZoomOut className="h-4 w-4"/></Button></TooltipTrigger><TooltipContent>Zoom out</TooltipContent></Tooltip>
                <div className="w-28 px-3 text-center text-sm">{Math.round(scale * 100)}%</div>
                <Tooltip><TooltipTrigger asChild><Button size="icon" variant="outline" onClick={onZoomIn}><ZoomIn className="h-4 w-4"/></Button></TooltipTrigger><TooltipContent>Zoom in</TooltipContent></Tooltip>
                <div className="w-40 px-3">
                  <Slider value={[scale]} min={0.25} max={3} step={0.05} onValueChange={(v) => setScale(v[0])} />
                </div>
              </div>

              <Separator orientation="vertical" className="h-8" />

              <Tooltip><TooltipTrigger asChild><Button size="icon" variant="outline" onClick={rotateCCW}><RotateCcw className="h-4 w-4"/></Button></TooltipTrigger><TooltipContent>Rotate CCW</TooltipContent></Tooltip>
              <Tooltip><TooltipTrigger asChild><Button size="icon" variant="outline" onClick={rotateCW}><RotateCw className="h-4 w-4"/></Button></TooltipTrigger><TooltipContent>Rotate CW</TooltipContent></Tooltip>
              <Tooltip><TooltipTrigger asChild><Button size="icon" variant="outline" onClick={onDownloadPdf}><Download className="h-4 w-4"/></Button></TooltipTrigger><TooltipContent>Download PDF</TooltipContent></Tooltip>
              <Tooltip><TooltipTrigger asChild><Button size="icon" variant="outline" onClick={onPrint}><Printer className="h-4 w-4"/></Button></TooltipTrigger><TooltipContent>Print</TooltipContent></Tooltip>

              <Separator orientation="vertical" className="h-8" />

              <div className="flex items-center gap-1">
                <Tooltip><TooltipTrigger asChild><Button size="icon" variant={showTextLayer ? "default" : "outline"} onClick={() => setShowTextLayer((v) => !v)}>{showTextLayer ? <Eye className="h-4 w-4"/> : <EyeOff className="h-4 w-4"/>}</Button></TooltipTrigger><TooltipContent>Toggle text layer</TooltipContent></Tooltip>
                <Tooltip><TooltipTrigger asChild><Button size="icon" variant={dark ? "default" : "outline"} onClick={toggleTheme}>{dark ? <Moon className="h-4 w-4"/> : <Sun className="h-4 w-4"/>}</Button></TooltipTrigger><TooltipContent>Theme</TooltipContent></Tooltip>
              </div>

              <div className="ml-auto flex items-center gap-2">
                <Input placeholder="Find text" value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} className="w-52" onKeyDown={(e) => e.key === "Enter" && onSearch()} />
                <Button variant="outline" onClick={onSearch}><Search className="h-4 w-4 mr-2"/>Find</Button>
              </div>
            </div>

            <div className="mt-3 grid grid-cols-12 gap-3">
              {/* Sidebar */}
              <div className="col-span-3 space-y-3">
                <Card>
                  <CardHeader className="pb-2"><CardTitle className="text-base flex items-center gap-2"><ListTree className="h-4 w-4"/>Signatures</CardTitle><CardDescription>Digital signatures detected</CardDescription></CardHeader>
                  <CardContent className="space-y-2">
                    {!signatures && <div className="text-muted-foreground text-sm">Load a PDF to analyze signatures.</div>}
                    {signatures && signatures.length === 0 && <div className="text-amber-600 text-sm flex items-center gap-2"><FileWarning className="h-4 w-4"/>No signatures found</div>}
                    {signatures && signatures.map((s, idx) => (<SignatureBadge key={idx} s={s}/>))}
                  </CardContent>
                </Card>

                {enableRevisionTimeline && (
                  <Card>
                    <CardHeader className="pb-2"><CardTitle className="text-base flex items-center gap-2"><Layers className="h-4 w-4"/>Revisions</CardTitle><CardDescription>Incremental updates (inferred)</CardDescription></CardHeader>
                    <CardContent className="space-y-2">
                      {revisions.length === 0 && <div className="text-sm text-muted-foreground">No revisions inferred yet.</div>}
                      {revisions.length > 0 && (
                        <ol className="list-decimal ml-4 text-sm space-y-1">
                          {revisions.map((r) => (<li key={r}>Revision {r} — sealed by signature</li>))}
                        </ol>
                      )}
                      <div className="text-xs text-muted-foreground mt-2">Note: PDF revisions are inferred from signature byte ranges. For authoritative change logs, perform server-side validation (DSS/OCSP/CRL).</div>
                    </CardContent>
                  </Card>
                )}

                {enableAnnotations && (
                  <Card>
                    <CardHeader className="pb-2"><CardTitle className="text-base flex items-center gap-2"><Type className="h-4 w-4"/>Annotations</CardTitle><CardDescription>Local highlights (visual only)</CardDescription></CardHeader>
                    <CardContent>
                      <div className="text-xs text-muted-foreground mb-2">Click-drag on the page to draw a highlight rectangle.</div>
                      <div className="text-sm">{annotRects.filter(a => a.page === pageNum).length} annotations on this page</div>
                      <div className="flex items-center gap-2 mt-2">
                        <Button variant="outline" size="sm" onClick={() => setAnnotRects((prev) => prev.filter(a => !(a.page === pageNum)))}><Undo2 className="h-4 w-4 mr-2"/>Clear page</Button>
                        <Button variant="outline" size="sm" onClick={() => setAnnotRects([])}><Redo2 className="h-4 w-4 mr-2"/>Clear all</Button>
                      </div>
                    </CardContent>
                  </Card>
                )}
              </div>

              {/* Main viewer */}
              <div className="col-span-9">
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center gap-2">
                    <Button variant="outline" size="icon" onClick={onPrev} disabled={pageNum <= 1}><ChevronLeft className="h-4 w-4"/></Button>
                    <div className="text-sm">Page {pageNum} / {pageCount || "–"}</div>
                    <Button variant="outline" size="icon" onClick={onNext} disabled={pageNum >= pageCount}><ChevronRight className="h-4 w-4"/></Button>
                  </div>
                  <div className="flex items-center gap-2">
                    <Button variant="outline" size="sm" onClick={onDownloadPagePng}>Export page PNG</Button>
                  </div>
                </div>

                <div className={"relative w-full overflow-auto rounded-2xl border bg-white " + (dark ? "dark bg-neutral-900" : "")}>
                  <div ref={containerRef} className="relative mx-auto select-none" style={{ minHeight: 200 }} />
                </div>

                <div className="mt-2 text-xs text-muted-foreground flex items-start gap-2">
                  <Info className="h-3.5 w-3.5 mt-0.5"/>
                  <div>
                    Signature validation here confirms cryptographic integrity of the signed byte ranges. For full LTV (OCSP/CRL/timestamp) and certification/permission checks, integrate a server-side validator (e.g., DSS/ETSI, iText/Adobe, pdfcpu, or DSS in Java). This component exposes parsed data for your backend to cross-verify.
                  </div>
                </div>
              </div>
            </div>
          </CardContent>
        </Card>
      </TooltipProvider>
    </div>
  );
}